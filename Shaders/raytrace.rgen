//https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/#raytracingpipeline
#version 460
//https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR/blob/master/ray_tracing_jitter_cam/shaders/random.glsl
#include "random.glsl"
#extension GL_EXT_ray_tracing : require

struct HitPayload
{
  vec3 hitValue;
  float reflectFactor;
  bool wasReflect;
  vec3 normal;
  vec3 hitPoint;
};

layout(location = 0) rayPayloadEXT HitPayload hitPayload;



layout(push_constant) uniform PushConstant { 
	int frame;
    int doReflect;
	int numSamples;
    int numBounces;
};

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D image;
layout(binding = 2, set = 0) uniform Camera{
    mat4 mat;
}camera; //inv
layout(binding = 3, set = 0) uniform Proj{
    mat4 mat;
}proj; //inv

void main() 
{
    //https://github.com/nvpro-samples/vk_raytracing_tutorial_KHR/tree/master/ray_tracing_jitter_cam
    uint rayFlags = gl_RayFlagsOpaqueEXT;
    float tmin = 0.001;
    float tmax = 1000000.0;
    vec3 color = vec3(0,0,0);
    for(int pass = 0; pass < numSamples; pass++){
        uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, numSamples*frame + pass);
        vec2 jitter = vec2(rnd(seed), rnd(seed));
        const vec2 uv = (vec2(gl_LaunchIDEXT.xy) + jitter) / gl_LaunchSizeEXT.xy;
        vec2 uvDir = uv*2.0 - 1.0;
        vec4 cameraOrigin = camera.mat*vec4(0,0,0,1);
        vec4 lensInter = proj.mat*vec4(uvDir.x,uvDir.y,1,1);
        vec4 rayDir = camera.mat*vec4(normalize(lensInter.xyz),0);
        traceRayEXT(topLevelAS, rayFlags, 0xFF, 0,0,0,
            cameraOrigin.xyz,tmin,rayDir.xyz,tmax,0);
        float reflectFactor = hitPayload.reflectFactor;
        bool wasReflected = hitPayload.wasReflect;
        vec3 thisColor = vec3(0);
        if(doReflect > 0){
            vec3 initialColor = hitPayload.hitValue;
            for(int bounce = 0; 
            bounce < numBounces && wasReflected && reflectFactor <= 1.0;
            bounce++){
                vec3 refDir = reflect(-rayDir.xyz,hitPayload.normal);
                vec3 hitPoint = hitPayload.hitPoint + 0.001 * refDir;
                traceRayEXT(topLevelAS, rayFlags, 0xFF, 0,0,0,
                hitPoint,tmin,refDir,tmax,0);
            
                initialColor = vec3(reflectFactor) * hitPayload.hitValue +
                vec3(1.0 - reflectFactor) * initialColor;
                reflectFactor = hitPayload.reflectFactor;
                wasReflected = hitPayload.wasReflect;
            }
            thisColor = initialColor;
        }
        else{
            thisColor = hitPayload.hitValue;
        }
        color += thisColor;
    }
    color /= numSamples;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
